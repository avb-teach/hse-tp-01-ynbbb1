#!/usr/bin/env bash 
# запускаем скрипт через Bash
set -euo pipefail # выход при ошибках
IFS=$'\n\t' # задаём набор символов-разделителей для чтения. оставляем только перевод строки и таб, чтобы безопасно обрабатывать имена файлов с пробелами

if [[ $# -lt 2 ]]; then
  echo "Usage: $0 INPUT_DIR OUTPUT_DIR [--max_depth N]"
  exit 1
fi
# меньше двух переданных аргументов, скрипт выводит подсказку и завершает работу

INPUT_DIR="$1" # $1 — первый аргумент, который мы дали
OUTPUT_DIR="$2" # $2 — второй аргумент, который мы дали
MAX_DEPTH=0

if [[ "${3-}" == "--max_depth" && "${4-}" =~ ^[0-9]+$ ]]; then
  MAX_DEPTH="$4"
fi
# если в 3 и 4 аргументе написаны "max_depth" и его значение соответственно, то задаем это значение для MAX_DEPTH

mkdir -p "$OUTPUT_DIR" 
if [[ ! -d "$INPUT_DIR" ]]; then
  exit 0
fi

find "$INPUT_DIR" -type f -print0 | while IFS= read -r -d '' src; do 
# запускаем утилиту find, чтобы найти все файлы (-type f) внутри INPUT_DIR. -print0 выводит каждый найденный путь, заканчивая его нулевым байтом (\0) вместо перевода строки. Конвейер (|) передаёт этот “нулёво-разделённый” поток дальше в цикл while
# while …; do … done — цикл, который повторяется, пока команда read возвращает 0 (успех). IFS= сбрасывает локально разделитель, чтобы read не разбивал строку по пробелам. -r отключает спец-обработку обратного слеша. -d '' говорит «читай до нулевого байта (\0)». в каждую итерацию src получает полный путь к одному файлу
  rel="${src#$INPUT_DIR/}" # удаляем префикс, получаем относительный путь внутри папки
  IFS='/' read -ra parts <<< "$rel" # разбивает строку rel на массив parts, где каждый элемент — один сегмент пути

  depth=${#parts[@]} # полная глубина = число сегментов (папки + имя файла)

  start=$(( depth - MAX_DEPTH )) # start - откуда брать последние MAX_DEPTH папок
  (( start < 0 )) && start=0 # если start получился отрицательным (когда depth < MAX_DEPTH), ставим start=0 — т.е. надо взять сразу все папки

  subpath=""
  for (( i = start; i < depth-1; i++ )); do
    subpath+="/${parts[i]}"
  done
  # собираем подпуть из parts[start] .. parts[depth-2]

  mkdir -p "$OUTPUT_DIR$subpath" 

  fname="${parts[depth-1]}" # последний элемент массива parts — это имя файла
  newname="$fname"; cnt=0

  while [[ -e "$OUTPUT_DIR$subpath/$newname" ]]; do # проверяем, существует ли уже файл с этим именем в папке
    (( cnt++ ))
    base="${fname%.*}"  # записываем всё имя до последней точки 
    ext="${fname##*.}" # записываем всё имя после последней точки
    if [[ "$base" == "$fname" ]]; then
      newname="${base}${cnt}" # если base совпадает с исходным именем (fname), значит в имени нет точки, т.е. нет расширения -> формируем как file1
    else
      newname="${base}${cnt}.${ext}" # если base не совпадает с исходным именем (fname), значит в имени есть точка, т.е. есть расширение -> вставляем суффикс перед точкой: file1.txt
    fi
  done

  cp -- "$src" "$OUTPUT_DIR$subpath/$newname" # копируем под гарантированно уникальным именем
done